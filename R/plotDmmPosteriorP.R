#' @importFrom stats dnbinom predict
#' @importFrom ggplot2 ggplot geom_histogram xlab ylab aes
.plotDmmPosteriorP <- function(model, log=FALSE, bins=50) {
  
  # Naive mixture model
  if (all(c("mu1", "mu2", "theta1", "theta2", "pi") %in% names(model))) {
    mu1=model$mu1
    mu2=model$mu2
    theta1=model$theta1
    theta2=model$theta2
    y <- model$y
    
    # Regression mixture model
  } else if (all(c("fit1", "fit2", "pi") %in% names(model))) {
    mu1 <- predict(model$fit1, type="response")
    mu2 <- predict(model$fit2, type="response")
    theta1 <- model$fit1$theta
    theta2 <- model$fit2$theta
    y <- model$fit1$y
  
  } else {
    stop("Parameter model must be a model generated by demuxmix().")
  }
  
  f <- matrix(nrow=length(y), ncol=2)
  f[, 1] <- dnbinom(y, mu=mu1, size=theta1)
  f[, 2] <- dnbinom(y, mu=mu2, size=theta2)
  pi.f <- t(model$pi * t(f))
  posteriorProb <- pi.f / apply(pi.f, 1, sum)
  df <- data.frame(posteriorProb=posteriorProb[, 2])
  
  p <- ggplot(df, aes(x=posteriorProb)) +
    geom_histogram(bins=bins) +
    xlab("Posterior probability") +
    ylab("Numer of cells")
  
  return(p)
}


#' @importFrom ggplot2 ggtitle
#' @importFrom gridExtra grid.arrange
setMethod("plotDmmPosteriorP", signature=c(model="list"),
  function (model, log=FALSE, bins=50) {
    # Only one model given (for one hashtag)
    if (all(c("mu1", "mu2", "theta1", "theta2", "pi") %in% names(model)) | all(c("fit1", "fit2", "pi") %in% names(model))) {
      return(.plotDmmPosteriorP(model, log=log, bins=bins))
              
    # List of models for multiple hashtags
    } else if (length(model) == 1) {
      return(.plotDmmPosteriorP(model[[1]], log=log, bins=bins))
    } else {
      plots <- lapply(model, .plotDmmPosteriorP, log, bins)
      for (i in 1:length(plots)) {
        plots[[i]] <- plots[[i]] + ggtitle(names(plots)[i])
      }
      return(do.call(grid.arrange, plots))
    }
  }
)