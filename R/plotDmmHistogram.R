#' @importFrom stats dnbinom qnbinom predict residuals density
#' @importFrom ggplot2 ggplot geom_histogram stat_function xlab ylab coord_cartesian aes stat
.plotDmmHistogram <- function(model, quantile=0.95, binwidth=50) {
  
  # Naive mixture model
  if (all(c("mu1", "mu2", "theta1", "theta2", "pi", "y") %in% names(model))) {
    mu1=model$mu1
    mu2=model$mu2
    theta1=model$theta1
    theta2=model$theta2
    pi=model$pi
    hto <- model$y
    if ("htoId" %in% names(model)) {
      xlab <- paste(model$htoId, "counts")
    } else {
      xlab <- "HTO counts"
    }
    
  # Regression mixture model
  } else if (all(c("fit1", "fit2", "pi") %in% names(model))) {
    mu1 <- predict(model$fit1, type="response")
    mu2 <- predict(model$fit2, type="response")
    theta1 <- model$fit1$theta
    theta2 <- model$fit2$theta
    pi=model$pi
    
    f <- matrix(nrow=length(mu1), ncol=2)
    f[, 1] <- dnbinom(model$fit1$y, mu=mu1, size=theta1)
    f[, 2] <- dnbinom(model$fit2$y, mu=mu2, size=theta2)
    pi.f <- t(pi * t(f))
    posteriorProb <- pi.f / apply(pi.f, 1, sum)
    rna <- model$fit1$model$rna
    rna1 <- sum(rna * posteriorProb[, 1]) / sum(posteriorProb[, 1])
    rna2 <- sum(rna * posteriorProb[, 2]) / sum(posteriorProb[, 2])
    predData1 <- data.frame(hto=model$fit1$y, rna=rna1)
    predData2 <- data.frame(hto=model$fit2$y, rna=rna2)
    mu1 <- predict(model$fit1, newdata=predData1, type="response")[1]
    mu2 <- predict(model$fit2, newdata=predData2, type="response")[1]
    hto <- ((mu1 + residuals(model$fit1, type="response")) * posteriorProb[, 1]) +
           ((mu2 + residuals(model$fit2, type="response")) * posteriorProb[, 2])
    
    if ("htoId" %in% names(model)) {
      xlab <- paste(model$htoId, "counts (adjusted for RNA)")
    } else {
      xlab <- "HTO counts (adjusted for RNA)"
    }
  } else {
    stop("Parameter model must be a model generated by demuxmix().")
  }
  
  comp1 <- function(x) {
    return(dnbinom(round(x), mu=mu1, size=theta1) * pi[1])
  }
  comp2 <- function(x) {
    return(dnbinom(round(x), mu=mu2, size=theta2) * pi[2])
  }
  mixture <- function(x) {
    return(comp1(x) + comp2(x))
  }
  
  xmax <- max(qnbinom(quantile, mu=mu1, size=theta1), qnbinom(quantile, mu=mu2, size=theta2))
  df <- data.frame(hto=hto)
  
  p = ggplot(df, aes(x=hto)) +
    geom_histogram(aes(y=stat(density)), alpha=0.4, binwidth=binwidth) +
    stat_function(fun=mixture, lwd=1, n=xmax, col="black") +
    stat_function(fun=comp1, lwd=1, n=xmax, col="dodgerblue") +
    stat_function(fun=comp2, lwd=1, n=xmax, col="firebrick2") +
    xlab(xlab) +
    ylab("Density") +
    coord_cartesian(xlim=c(0, xmax))
  
  return(p)
}


#' @importFrom ggplot2 ggtitle
#' @importFrom gridExtra grid.arrange
setMethod("plotDmmHistogram", signature=c(model="list"),
  function (model, quantile=0.95, binwidth=50) {
    # Only one model given (for one hashtag)
    if (all(c("mu1", "mu2", "theta1", "theta2", "pi") %in% names(model)) | all(c("fit1", "fit2", "pi") %in% names(model))) {
      return(.plotDmmHistogram(model, quantile=quantile, binwidth=binwidth))
              
    # List of models for multiple hashtags
    } else if (length(model) == 1) {
      return(.plotDmmHistogram(model[[1]], quantile=quantile, binwidth=binwidth))
    } else {
      plots <- lapply(model, .plotDmmHistogram, quantile, binwidth)
      for (i in 1:length(plots)) {
        plots[[i]] <- plots[[i]] + ggtitle(names(plots)[i])
      }
      return(do.call(grid.arrange, plots))
    }
  }
)